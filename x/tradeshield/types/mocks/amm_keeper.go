// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
	math "cosmossdk.io/math"
	ammtypes "github.com/elys-network/elys/x/amm/types"

	mock "github.com/stretchr/testify/mock"

	types "github.com/cosmos/cosmos-sdk/types"
)

// AmmKeeper is an autogenerated mock type for the AmmKeeper type
type AmmKeeper struct {
	mock.Mock
}

type AmmKeeper_Expecter struct {
	mock *mock.Mock
}

func (_m *AmmKeeper) EXPECT() *AmmKeeper_Expecter {
	return &AmmKeeper_Expecter{mock: &_m.Mock}
}

// CalcInAmtGivenOut provides a mock function with given fields: ctx, poolId, oracle, snapshot, tokensOut, tokenInDenom, swapFee
func (_m *AmmKeeper) CalcInAmtGivenOut(ctx types.Context, poolId uint64, oracle ammtypes.OracleKeeper, snapshot *ammtypes.Pool, tokensOut types.Coins, tokenInDenom string, swapFee math.LegacyDec) (types.Coin, math.LegacyDec, error) {
	ret := _m.Called(ctx, poolId, oracle, snapshot, tokensOut, tokenInDenom, swapFee)

	var r0 types.Coin
	var r1 math.LegacyDec
	var r2 error
	if rf, ok := ret.Get(0).(func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) (types.Coin, math.LegacyDec, error)); ok {
		return rf(ctx, poolId, oracle, snapshot, tokensOut, tokenInDenom, swapFee)
	}
	if rf, ok := ret.Get(0).(func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) types.Coin); ok {
		r0 = rf(ctx, poolId, oracle, snapshot, tokensOut, tokenInDenom, swapFee)
	} else {
		r0 = ret.Get(0).(types.Coin)
	}

	if rf, ok := ret.Get(1).(func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) math.LegacyDec); ok {
		r1 = rf(ctx, poolId, oracle, snapshot, tokensOut, tokenInDenom, swapFee)
	} else {
		r1 = ret.Get(1).(math.LegacyDec)
	}

	if rf, ok := ret.Get(2).(func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) error); ok {
		r2 = rf(ctx, poolId, oracle, snapshot, tokensOut, tokenInDenom, swapFee)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AmmKeeper_CalcInAmtGivenOut_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalcInAmtGivenOut'
type AmmKeeper_CalcInAmtGivenOut_Call struct {
	*mock.Call
}

// CalcInAmtGivenOut is a helper method to define mock.On call
//   - ctx types.Context
//   - poolId uint64
//   - oracle ammtypes.OracleKeeper
//   - snapshot *ammtypes.Pool
//   - tokensOut types.Coins
//   - tokenInDenom string
//   - swapFee math.LegacyDec
func (_e *AmmKeeper_Expecter) CalcInAmtGivenOut(ctx interface{}, poolId interface{}, oracle interface{}, snapshot interface{}, tokensOut interface{}, tokenInDenom interface{}, swapFee interface{}) *AmmKeeper_CalcInAmtGivenOut_Call {
	return &AmmKeeper_CalcInAmtGivenOut_Call{Call: _e.mock.On("CalcInAmtGivenOut", ctx, poolId, oracle, snapshot, tokensOut, tokenInDenom, swapFee)}
}

func (_c *AmmKeeper_CalcInAmtGivenOut_Call) Run(run func(ctx types.Context, poolId uint64, oracle ammtypes.OracleKeeper, snapshot *ammtypes.Pool, tokensOut types.Coins, tokenInDenom string, swapFee math.LegacyDec)) *AmmKeeper_CalcInAmtGivenOut_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Context), args[1].(uint64), args[2].(ammtypes.OracleKeeper), args[3].(*ammtypes.Pool), args[4].(types.Coins), args[5].(string), args[6].(math.LegacyDec))
	})
	return _c
}

func (_c *AmmKeeper_CalcInAmtGivenOut_Call) Return(tokenIn types.Coin, slippage math.LegacyDec, err error) *AmmKeeper_CalcInAmtGivenOut_Call {
	_c.Call.Return(tokenIn, slippage, err)
	return _c
}

func (_c *AmmKeeper_CalcInAmtGivenOut_Call) RunAndReturn(run func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) (types.Coin, math.LegacyDec, error)) *AmmKeeper_CalcInAmtGivenOut_Call {
	_c.Call.Return(run)
	return _c
}

// CalcOutAmtGivenIn provides a mock function with given fields: ctx, poolId, oracle, snapshot, tokensIn, tokenOutDenom, swapFee
func (_m *AmmKeeper) CalcOutAmtGivenIn(ctx types.Context, poolId uint64, oracle ammtypes.OracleKeeper, snapshot *ammtypes.Pool, tokensIn types.Coins, tokenOutDenom string, swapFee math.LegacyDec) (types.Coin, math.LegacyDec, error) {
	ret := _m.Called(ctx, poolId, oracle, snapshot, tokensIn, tokenOutDenom, swapFee)

	var r0 types.Coin
	var r1 math.LegacyDec
	var r2 error
	if rf, ok := ret.Get(0).(func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) (types.Coin, math.LegacyDec, error)); ok {
		return rf(ctx, poolId, oracle, snapshot, tokensIn, tokenOutDenom, swapFee)
	}
	if rf, ok := ret.Get(0).(func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) types.Coin); ok {
		r0 = rf(ctx, poolId, oracle, snapshot, tokensIn, tokenOutDenom, swapFee)
	} else {
		r0 = ret.Get(0).(types.Coin)
	}

	if rf, ok := ret.Get(1).(func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) math.LegacyDec); ok {
		r1 = rf(ctx, poolId, oracle, snapshot, tokensIn, tokenOutDenom, swapFee)
	} else {
		r1 = ret.Get(1).(math.LegacyDec)
	}

	if rf, ok := ret.Get(2).(func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) error); ok {
		r2 = rf(ctx, poolId, oracle, snapshot, tokensIn, tokenOutDenom, swapFee)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AmmKeeper_CalcOutAmtGivenIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalcOutAmtGivenIn'
type AmmKeeper_CalcOutAmtGivenIn_Call struct {
	*mock.Call
}

// CalcOutAmtGivenIn is a helper method to define mock.On call
//   - ctx types.Context
//   - poolId uint64
//   - oracle ammtypes.OracleKeeper
//   - snapshot *ammtypes.Pool
//   - tokensIn types.Coins
//   - tokenOutDenom string
//   - swapFee math.LegacyDec
func (_e *AmmKeeper_Expecter) CalcOutAmtGivenIn(ctx interface{}, poolId interface{}, oracle interface{}, snapshot interface{}, tokensIn interface{}, tokenOutDenom interface{}, swapFee interface{}) *AmmKeeper_CalcOutAmtGivenIn_Call {
	return &AmmKeeper_CalcOutAmtGivenIn_Call{Call: _e.mock.On("CalcOutAmtGivenIn", ctx, poolId, oracle, snapshot, tokensIn, tokenOutDenom, swapFee)}
}

func (_c *AmmKeeper_CalcOutAmtGivenIn_Call) Run(run func(ctx types.Context, poolId uint64, oracle ammtypes.OracleKeeper, snapshot *ammtypes.Pool, tokensIn types.Coins, tokenOutDenom string, swapFee math.LegacyDec)) *AmmKeeper_CalcOutAmtGivenIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Context), args[1].(uint64), args[2].(ammtypes.OracleKeeper), args[3].(*ammtypes.Pool), args[4].(types.Coins), args[5].(string), args[6].(math.LegacyDec))
	})
	return _c
}

func (_c *AmmKeeper_CalcOutAmtGivenIn_Call) Return(_a0 types.Coin, _a1 math.LegacyDec, _a2 error) *AmmKeeper_CalcOutAmtGivenIn_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AmmKeeper_CalcOutAmtGivenIn_Call) RunAndReturn(run func(types.Context, uint64, ammtypes.OracleKeeper, *ammtypes.Pool, types.Coins, string, math.LegacyDec) (types.Coin, math.LegacyDec, error)) *AmmKeeper_CalcOutAmtGivenIn_Call {
	_c.Call.Return(run)
	return _c
}

// CalcSwapEstimationByDenom provides a mock function with given fields: ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals
func (_m *AmmKeeper) CalcSwapEstimationByDenom(ctx types.Context, amount types.Coin, denomIn string, denomOut string, baseCurrency string, discount math.LegacyDec, overrideSwapFee math.LegacyDec, decimals uint64) ([]*ammtypes.SwapAmountInRoute, []*ammtypes.SwapAmountOutRoute, types.Coin, math.LegacyDec, math.LegacyDec, math.LegacyDec, types.Coin, math.LegacyDec, math.LegacyDec, math.LegacyDec, error) {
	ret := _m.Called(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)

	var r0 []*ammtypes.SwapAmountInRoute
	var r1 []*ammtypes.SwapAmountOutRoute
	var r2 types.Coin
	var r3 math.LegacyDec
	var r4 math.LegacyDec
	var r5 math.LegacyDec
	var r6 types.Coin
	var r7 math.LegacyDec
	var r8 math.LegacyDec
	var r9 math.LegacyDec
	var r10 error
	if rf, ok := ret.Get(0).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) ([]*ammtypes.SwapAmountInRoute, []*ammtypes.SwapAmountOutRoute, types.Coin, math.LegacyDec, math.LegacyDec, math.LegacyDec, types.Coin, math.LegacyDec, math.LegacyDec, math.LegacyDec, error)); ok {
		return rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	}
	if rf, ok := ret.Get(0).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) []*ammtypes.SwapAmountInRoute); ok {
		r0 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ammtypes.SwapAmountInRoute)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) []*ammtypes.SwapAmountOutRoute); ok {
		r1 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*ammtypes.SwapAmountOutRoute)
		}
	}

	if rf, ok := ret.Get(2).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) types.Coin); ok {
		r2 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		r2 = ret.Get(2).(types.Coin)
	}

	if rf, ok := ret.Get(3).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) math.LegacyDec); ok {
		r3 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		r3 = ret.Get(3).(math.LegacyDec)
	}

	if rf, ok := ret.Get(4).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) math.LegacyDec); ok {
		r4 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		r4 = ret.Get(4).(math.LegacyDec)
	}

	if rf, ok := ret.Get(5).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) math.LegacyDec); ok {
		r5 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		r5 = ret.Get(5).(math.LegacyDec)
	}

	if rf, ok := ret.Get(6).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) types.Coin); ok {
		r6 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		r6 = ret.Get(6).(types.Coin)
	}

	if rf, ok := ret.Get(7).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) math.LegacyDec); ok {
		r7 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		r7 = ret.Get(7).(math.LegacyDec)
	}

	if rf, ok := ret.Get(8).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) math.LegacyDec); ok {
		r8 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		r8 = ret.Get(8).(math.LegacyDec)
	}

	if rf, ok := ret.Get(9).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) math.LegacyDec); ok {
		r9 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		r9 = ret.Get(9).(math.LegacyDec)
	}

	if rf, ok := ret.Get(10).(func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) error); ok {
		r10 = rf(ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)
	} else {
		r10 = ret.Error(10)
	}

	return r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10
}

// AmmKeeper_CalcSwapEstimationByDenom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalcSwapEstimationByDenom'
type AmmKeeper_CalcSwapEstimationByDenom_Call struct {
	*mock.Call
}

// CalcSwapEstimationByDenom is a helper method to define mock.On call
//   - ctx types.Context
//   - amount types.Coin
//   - denomIn string
//   - denomOut string
//   - baseCurrency string
//   - discount math.LegacyDec
//   - overrideSwapFee math.LegacyDec
//   - decimals uint64
func (_e *AmmKeeper_Expecter) CalcSwapEstimationByDenom(ctx interface{}, amount interface{}, denomIn interface{}, denomOut interface{}, baseCurrency interface{}, discount interface{}, overrideSwapFee interface{}, decimals interface{}) *AmmKeeper_CalcSwapEstimationByDenom_Call {
	return &AmmKeeper_CalcSwapEstimationByDenom_Call{Call: _e.mock.On("CalcSwapEstimationByDenom", ctx, amount, denomIn, denomOut, baseCurrency, discount, overrideSwapFee, decimals)}
}

func (_c *AmmKeeper_CalcSwapEstimationByDenom_Call) Run(run func(ctx types.Context, amount types.Coin, denomIn string, denomOut string, baseCurrency string, discount math.LegacyDec, overrideSwapFee math.LegacyDec, decimals uint64)) *AmmKeeper_CalcSwapEstimationByDenom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Context), args[1].(types.Coin), args[2].(string), args[3].(string), args[4].(string), args[5].(math.LegacyDec), args[6].(math.LegacyDec), args[7].(uint64))
	})
	return _c
}

func (_c *AmmKeeper_CalcSwapEstimationByDenom_Call) Return(inRoute []*ammtypes.SwapAmountInRoute, outRoute []*ammtypes.SwapAmountOutRoute, outAmount types.Coin, spotPrice math.LegacyDec, swapFee math.LegacyDec, discountOut math.LegacyDec, availableLiquidity types.Coin, slippage math.LegacyDec, weightBonus math.LegacyDec, priceImpact math.LegacyDec, err error) *AmmKeeper_CalcSwapEstimationByDenom_Call {
	_c.Call.Return(inRoute, outRoute, outAmount, spotPrice, swapFee, discountOut, availableLiquidity, slippage, weightBonus, priceImpact, err)
	return _c
}

func (_c *AmmKeeper_CalcSwapEstimationByDenom_Call) RunAndReturn(run func(types.Context, types.Coin, string, string, string, math.LegacyDec, math.LegacyDec, uint64) ([]*ammtypes.SwapAmountInRoute, []*ammtypes.SwapAmountOutRoute, types.Coin, math.LegacyDec, math.LegacyDec, math.LegacyDec, types.Coin, math.LegacyDec, math.LegacyDec, math.LegacyDec, error)) *AmmKeeper_CalcSwapEstimationByDenom_Call {
	_c.Call.Return(run)
	return _c
}

// SwapByDenom provides a mock function with given fields: ctx, msg
func (_m *AmmKeeper) SwapByDenom(ctx types.Context, msg *ammtypes.MsgSwapByDenom) (*ammtypes.MsgSwapByDenomResponse, error) {
	ret := _m.Called(ctx, msg)

	var r0 *ammtypes.MsgSwapByDenomResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Context, *ammtypes.MsgSwapByDenom) (*ammtypes.MsgSwapByDenomResponse, error)); ok {
		return rf(ctx, msg)
	}
	if rf, ok := ret.Get(0).(func(types.Context, *ammtypes.MsgSwapByDenom) *ammtypes.MsgSwapByDenomResponse); ok {
		r0 = rf(ctx, msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ammtypes.MsgSwapByDenomResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Context, *ammtypes.MsgSwapByDenom) error); ok {
		r1 = rf(ctx, msg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AmmKeeper_SwapByDenom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SwapByDenom'
type AmmKeeper_SwapByDenom_Call struct {
	*mock.Call
}

// SwapByDenom is a helper method to define mock.On call
//   - ctx types.Context
//   - msg *ammtypes.MsgSwapByDenom
func (_e *AmmKeeper_Expecter) SwapByDenom(ctx interface{}, msg interface{}) *AmmKeeper_SwapByDenom_Call {
	return &AmmKeeper_SwapByDenom_Call{Call: _e.mock.On("SwapByDenom", ctx, msg)}
}

func (_c *AmmKeeper_SwapByDenom_Call) Run(run func(ctx types.Context, msg *ammtypes.MsgSwapByDenom)) *AmmKeeper_SwapByDenom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Context), args[1].(*ammtypes.MsgSwapByDenom))
	})
	return _c
}

func (_c *AmmKeeper_SwapByDenom_Call) Return(_a0 *ammtypes.MsgSwapByDenomResponse, _a1 error) *AmmKeeper_SwapByDenom_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AmmKeeper_SwapByDenom_Call) RunAndReturn(run func(types.Context, *ammtypes.MsgSwapByDenom) (*ammtypes.MsgSwapByDenomResponse, error)) *AmmKeeper_SwapByDenom_Call {
	_c.Call.Return(run)
	return _c
}

// NewAmmKeeper creates a new instance of AmmKeeper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAmmKeeper(t interface {
	mock.TestingT
	Cleanup(func())
}) *AmmKeeper {
	mock := &AmmKeeper{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
