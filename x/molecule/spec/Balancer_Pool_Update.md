# Osmosis AMM Pool

```go
type Pool struct {
	Address    string
	Id         uint64
	PoolParams PoolParams
	// This string specifies who will govern the pool in the future.
	// Valid forms of this are:
	// {token name},{duration}
	// {duration}
	// where {token name} if specified is the token which determines the
	// governor, and if not specified is the LP token for this pool.duration is
	// a time specified as 0w,1w,2w, etc. which specifies how long the token
	// would need to be locked up to count in governance. 0w means no lockup.
	FuturePoolGovernor string
	// sum of all LP tokens sent out
	TotalShares sdk.Coin
	// These are assumed to be sorted by denomiation.
	// They contain the pool asset and the information about the weight
	PoolAssets []PoolAsset
	// sum of all non-normalized pool weights
	TotalWeight sdk.Int
}

type PoolParams struct {
	SwapFee                  sdk.Dec
	ExitFee                  sdk.Dec
	SmoothWeightChangeParams *SmoothWeightChangeParams
}

type SmoothWeightChangeParams struct {
	// The start time for beginning the weight change.
	// If a parameter change / pool instantiation leaves this blank,
	// it should be generated by the state_machine as the current time.
	StartTime time.Time
	// Duration for the weights to change over
	Duration time.Duration
	// The initial pool weights. These are copied from the pool's settings
	// at the time of weight change instantiation.
	// The amount PoolAsset.token.amount field is ignored if present,
	// future type refactorings should just have a type with the denom & weight
	// here.
	InitialPoolWeights []PoolAsset
	// The target pool weights. The pool weights will change linearly with respect
	// to time between start_time, and start_time + duration. The amount
	// PoolAsset.token.amount field is ignored if present, future type
	// refactorings should just have a type with the denom & weight here.
	TargetPoolWeights []PoolAsset
}

type PoolAsset struct {
	// Coins we are talking about,
	// the denomination must be unique amongst all PoolAssets for this pool.
	Token sdk.Coin
	// Weight that is not normalized. This weight must be less than 2^50
	Weight sdk.Int
}
```

# PoolParams change on Elys

```go
type PoolParams struct {
	SwapFee                  sdk.Dec
	ExitFee                  sdk.Dec
	SmoothWeightChangeParams *SmoothWeightChangeParams
	WeightBreakingFee        sdk.Dec
    UseOracle                bool
    SlippageReduction        sdk.Dec
}
```

- `UseOracle` is set to true when the weights are dynamically calculated based on oracle.
- `SlippageReduction` is positive for major tokens like BTC, ETH, USDC pools to provide lowest slippage possible for Elys users

# Swap logic change on Elys

Swap logic should be different per oracle case and no oracle case. Weight is dynamically determined from oracle and based on new weight, swap out amount is determined.

```go
Slippage = (InAmount/Spot_Price - Swap_out_amount) / (InAmount/Spot_Price)
ActualSlippage = Slippage * params.SlippageReduction
```

## Osmosis swap logic

```go
func (server msgServer) SwapExactAmountIn(goCtx context.Context, msg *types.MsgSwapExactAmountIn) (*types.MsgSwapExactAmountInResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)

	sender, err := sdk.AccAddressFromBech32(msg.Sender)
	if err != nil {
		return nil, err
	}

	tokenOutAmount, err := server.keeper.MultihopSwapExactAmountIn(ctx, sender, msg.Routes, msg.TokenIn, msg.TokenOutMinAmount)
	if err != nil {
		return nil, err
	}

	// Swap event is handled elsewhere
	ctx.EventManager().EmitEvents(sdk.Events{
		sdk.NewEvent(
			sdk.EventTypeMessage,
			sdk.NewAttribute(sdk.AttributeKeyModule, types.AttributeValueCategory),
			sdk.NewAttribute(sdk.AttributeKeySender, msg.Sender),
		),
	})

	return &types.MsgSwapExactAmountInResponse{TokenOutAmount: tokenOutAmount}, nil
}

func (server msgServer) SwapExactAmountOut(goCtx context.Context, msg *types.MsgSwapExactAmountOut) (*types.MsgSwapExactAmountOutResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)

	sender, err := sdk.AccAddressFromBech32(msg.Sender)
	if err != nil {
		return nil, err
	}

	tokenInAmount, err := server.keeper.MultihopSwapExactAmountOut(ctx, sender, msg.Routes, msg.TokenInMaxAmount, msg.TokenOut)
	if err != nil {
		return nil, err
	}

	// Swap event is handled elsewhere
	ctx.EventManager().EmitEvents(sdk.Events{
		sdk.NewEvent(
			sdk.EventTypeMessage,
			sdk.NewAttribute(sdk.AttributeKeyModule, types.AttributeValueCategory),
			sdk.NewAttribute(sdk.AttributeKeySender, msg.Sender),
		),
	})

	return &types.MsgSwapExactAmountOutResponse{TokenInAmount: tokenInAmount}, nil
}
```

## Fees on normal AMM

Swap Fee

## Fees on hybrid AMM

Swap Fee + WeightBreakFee

```go
WeightDiffAvg = Average(abs(Weight - TargetWeight))
WeightBreak = max(WeightDiffAvg(AfterAction) - WeightDiffAvg(BeforeAction), 0)
WeightBreakFee = WeightBreak \* WeightBreakingFee
```

Note:
WeightBreakFee goes to WeightRecoveryTreasury

# AddLiquidity logic change on Elys

AddLiquidity logic should be different per oracle case and no oracle case.

## Osmosis add liquidity logic

```go
func (server msgServer) JoinPool(goCtx context.Context, msg *types.MsgJoinPool) (*types.MsgJoinPoolResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)

	sender, err := sdk.AccAddressFromBech32(msg.Sender)
	if err != nil {
		return nil, err
	}

	neededLp, sharesOut, err := server.keeper.JoinPoolNoSwap(ctx, sender, msg.PoolId, msg.ShareOutAmount, msg.TokenInMaxs)
	if err != nil {
		return nil, err
	}

	ctx.EventManager().EmitEvents(sdk.Events{
		sdk.NewEvent(
			sdk.EventTypeMessage,
			sdk.NewAttribute(sdk.AttributeKeyModule, types.AttributeValueCategory),
			sdk.NewAttribute(sdk.AttributeKeySender, msg.Sender),
		),
	})

	return &types.MsgJoinPoolResponse{
		ShareOutAmount: sharesOut,
		TokenIn:        neededLp,
	}, nil
}
```

## Fees on normal AMM

No Fee on Add liquidity

## Fees on hybrid AMM

WeightBreakFee

```go
WeightDiffAvg = Average(abs(Weight - TargetWeight))
WeightBreak = max(WeightDiffAvg(AfterAction) - WeightDiffAvg(BeforeAction), 0)
WeightBreakFee = WeightBreak \* WeightBreakingFee
```

Note:
WeightBreakFee goes to WeightRecoveryTreasury

# RemoveLiquidity logic change on Elys

RemoveLiquidity logic should be different per oracle case and no oracle case.

## Osmosis remove liquidity logic

```go
func (server msgServer) ExitPool(goCtx context.Context, msg *types.MsgExitPool) (*types.MsgExitPoolResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)

	sender, err := sdk.AccAddressFromBech32(msg.Sender)
	if err != nil {
		return nil, err
	}

	exitCoins, err := server.keeper.ExitPool(ctx, sender, msg.PoolId, msg.ShareInAmount, msg.TokenOutMins)
	if err != nil {
		return nil, err
	}

	ctx.EventManager().EmitEvents(sdk.Events{
		sdk.NewEvent(
			sdk.EventTypeMessage,
			sdk.NewAttribute(sdk.AttributeKeyModule, types.AttributeValueCategory),
			sdk.NewAttribute(sdk.AttributeKeySender, msg.Sender),
		),
	})

	return &types.MsgExitPoolResponse{
		TokenOut: exitCoins,
	}, nil
}
```

## Fees on normal AMM

Exit Fee on Remove liquidity

## Fees on hybrid AMM

Exit Fee + WeightBreakFee

```go
WeightDiffAvg = Average(abs(Weight - TargetWeight))
WeightBreak = max(WeightDiffAvg(AfterAction) - WeightDiffAvg(BeforeAction), 0)
WeightBreakFee = WeightBreak \* WeightBreakingFee
```

Note:
WeightBreakFee goes to WeightRecoveryTreasury

# Fee distribution logic change on Elys

Fee distribution logic will need to be completely rebuilt.

# Pool params update via governance

Pool params will need to be governed by governance.

# Risk management scenarios & solutions on hybrid AMM model

- Arbitrage opportunity?
- Permanent loss for LPs for providing better swap?
- Utilization rate vs loss?
- Oracle accuracy assumption - TODO: calculate on loss amount when oracle has 1% price difference with Osmosis.
- How much do LPs loss when price go down and recover to original?
