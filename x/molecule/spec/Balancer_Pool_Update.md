# Osmosis AMM Pool

```go
type Pool struct {
	Address    string
	Id         uint64
	PoolParams PoolParams
	// This string specifies who will govern the pool in the future.
	// Valid forms of this are:
	// {token name},{duration}
	// {duration}
	// where {token name} if specified is the token which determines the
	// governor, and if not specified is the LP token for this pool.duration is
	// a time specified as 0w,1w,2w, etc. which specifies how long the token
	// would need to be locked up to count in governance. 0w means no lockup.
	FuturePoolGovernor string
	// sum of all LP tokens sent out
	TotalShares sdk.Coin
	// These are assumed to be sorted by denomiation.
	// They contain the pool asset and the information about the weight
	PoolAssets []PoolAsset
	// sum of all non-normalized pool weights
	TotalWeight sdk.Int
}

type PoolParams struct {
	SwapFee                  sdk.Dec
	ExitFee                  sdk.Dec
	SmoothWeightChangeParams *SmoothWeightChangeParams
}

type SmoothWeightChangeParams struct {
	// The start time for beginning the weight change.
	// If a parameter change / pool instantiation leaves this blank,
	// it should be generated by the state_machine as the current time.
	StartTime time.Time
	// Duration for the weights to change over
	Duration time.Duration
	// The initial pool weights. These are copied from the pool's settings
	// at the time of weight change instantiation.
	// The amount PoolAsset.token.amount field is ignored if present,
	// future type refactorings should just have a type with the denom & weight
	// here.
	InitialPoolWeights []PoolAsset
	// The target pool weights. The pool weights will change linearly with respect
	// to time between start_time, and start_time + duration. The amount
	// PoolAsset.token.amount field is ignored if present, future type
	// refactorings should just have a type with the denom & weight here.
	TargetPoolWeights []PoolAsset
}

type PoolAsset struct {
	// Coins we are talking about,
	// the denomination must be unique amongst all PoolAssets for this pool.
	Token sdk.Coin
	// Weight that is not normalized. This weight must be less than 2^50
	Weight sdk.Int
}
```

# PoolParams change on Elys

```go
type PoolParams struct {
	SwapFee                  sdk.Dec
	ExitFee                  sdk.Dec
	SmoothWeightChangeParams *SmoothWeightChangeParams
    UseOracle                bool
    SlippageReduction        sdk.Dec
}
```

- `UseOracle` is set to true when the weights are dynamically calculated based on oracle.
- `SlippageReduction` is positive for major tokens like BTC, ETH, USDC pools to provide lowest slippage possible for Elys users

# Swap logic change on Elys

Swap logic should be different per oracle case and no oracle case.

# AddLiquidity logic change on Elys

AddLiquidity logic should be different per oracle case and no oracle case.

# RemoveLiquidity logic change on Elys

RemoveLiquidity logic should be different per oracle case and no oracle case.

# Fee distribution logic change on Elys

Fee distribution logic will need to be completely rebuilt.

# Pool params update via governance

Pool params will need to be governed by governance.

# Risk management scenarios & solutions on hybrid AMM model

- Arbitrage opportunity?
- Permanent loss for LPs for providing better swap?
- Utilization rate vs loss?
- Oracle accuracy assumption - TODO: calculate on loss amount when oracle has 1% price difference with Osmosis.
- How much do LPs loss when price go down and recover to original?
